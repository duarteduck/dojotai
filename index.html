<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Dojotai</title>
  <style>
    <?!= include('styles_base'); ?>
    <?!= include('styles_components'); ?>
  </style>
</head>
<body>
  <div id="app"></div>

  <!-- Templates (views & components) -->
  <template id="tpl-login"><?!= include('view_login'); ?></template>
  <template id="tpl-dash"><?!= include('view_dash'); ?></template>
  <template id="tpl-new"><?!= include('view_activity_new'); ?></template>
  <template id="tpl-activity-card"><?!= include('view_component_activityCard'); ?></template>
  <template id="tpl-empty"><?!= include('view_component_emptyState'); ?></template>
  <template id="tpl-toast"><?!= include('view_component_toast'); ?></template>

  <!-- Scripts (estado, api, ui, router) -->
  <?!= include('app_state'); ?>
  <?!= include('app_api'); ?>
  <?!= include('app_ui'); ?>
  <?!= include('app_router'); ?>
  
  <script>
    // Bootstrap ap√≥s DOM (evita race em alguns devices/iframes)
    document.addEventListener('DOMContentLoaded', () => Router.start(), { once:true });
  </script>

  <script>
    // Ajuste de 100vh no mobile
    (function(){
      function setVh(){ document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px'); }
      window.addEventListener('resize', setVh);
      window.addEventListener('orientationchange', setVh);
      setVh();
    })();
  </script>

  <script>
  (() => {
    function applyMobileOverride(){
      const inIframe   = (window.top !== window.self);       // app est√° embutido?
      const isTouch    = matchMedia('(pointer: coarse)').matches;
      const screenCSSW = Math.min(screen.width, screen.height); // largura real do device em CSS px
      const smallDevice= screenCSSW <= 480;                   // ajuste se quiser (ex.: 540)
      const wideVP     = innerWidth >= 700;                   // pega o caso 980px
      const looks980   = innerWidth === 980 || (window.visualViewport && Math.round(visualViewport.width) === 980);
      document.documentElement.classList.toggle(
        'force-mobile',
        inIframe && isTouch && smallDevice && (wideVP || looks980)
      );
    }
    addEventListener('resize', applyMobileOverride);
    addEventListener('orientationchange', applyMobileOverride);
    applyMobileOverride();
  })();
  </script>

  <script>
  (() => {
    function updateFlags(){
      const el = document.documentElement;
      const inIframe   = (top !== self);
      const isTouch    = matchMedia('(pointer: coarse)').matches;
      const screenCSSW = Math.min(screen.width, screen.height);  // largura real do device em CSS px
      const smallDev   = screenCSSW <= 480;                      // ajuste para 540 se preferir
      const wideVP     = innerWidth >= 700;
      const looks980   = innerWidth === 980 || (visualViewport && Math.round(visualViewport.width) === 980);

      el.classList.toggle('small-screen', smallDev);                   // classe para mobile real
      el.classList.toggle('force-mobile', inIframe && isTouch && smallDev && (wideVP || looks980)); // iframe 980
    }
    addEventListener('resize', updateFlags);
    addEventListener('orientationchange', updateFlags);
    updateFlags();
  })();
  </script>

  <script>
  (() => {
    // Ajuste base desejada para mobile quando N√ÉO houver problema (em px):
    const BASE_MOBILE_REM = 18;   // experimente 19/20 se preferir maior

    function applyAutoRem() {
      const root = document.documentElement;
      const isTouch = matchMedia('(pointer: coarse)').matches;
      const screenCSS = Math.min(screen.width, screen.height) || 480; // largura real do device
      const layoutW = innerWidth || 980;                              // largura que o CSS est√° vendo
      const wideLike = layoutW >= 700;                                // pega o caso 980
      const inIframe = (top !== self);

      // fator de "apertamento": se layout √© 980 e device ~432, f ‚âà 980/432 ‚âà 2.27
      const squeezeFactor = Math.max(1, layoutW / screenCSS);

      // Se for touch + viewport "larg√£o" (ou em iframe), compensamos multiplicando o rem
      const needsComp = isTouch && (inIframe || wideLike) && squeezeFactor > 1.05;

      // rem final: base * fator (com limites para n√£o exagerar)
      const remPx = needsComp
        ? Math.max(18, Math.min(BASE_MOBILE_REM * squeezeFactor, 34)) // clamp 18..34
        : BASE_MOBILE_REM;

      // aplica com prioridade alta
      root.style.setProperty('font-size', remPx + 'px', 'important');

      // ergonomia b√°sica (opcional)
      document.body && document.body.style.setProperty('line-height', '1.6', 'important');
    }

    addEventListener('resize', applyAutoRem);
    addEventListener('orientationchange', applyAutoRem);
    applyAutoRem();
  })();
  </script>

  <!-- ===== NOVO: SCRIPT AVAN√áADO DE DETEC√á√ÉO DO IFRAME 980px ===== -->
  <script>
  (() => {
    // ===== SISTEMA AVAN√áADO DE DETEC√á√ÉO DO IFRAME 980px =====
    
    function detectAndFixMobile() {
      const root = document.documentElement;
      
      // Detec√ß√µes b√°sicas
      const inIframe = (window.top !== window.self);
      const isTouch = matchMedia('(pointer: coarse)').matches;
      const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      
      // Dimens√µes reais vs CSS
      const screenRealW = Math.min(screen.width, screen.height); // Menor dimens√£o real
      const viewportW = window.innerWidth;
      const documentW = document.documentElement.clientWidth;
      
      // Detec√ß√£o espec√≠fica do iframe 980px do Apps Script
      const looks980 = viewportW === 980 || documentW === 980;
      const bigViewportSmallScreen = viewportW >= 700 && screenRealW <= 480;
      
      // User agent mobile
      const mobileUA = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      // Combina√ß√µes que indicam iframe 980px problem√°tico
      const isProblematic = inIframe && (isTouch || hasTouch || mobileUA) && 
                            (looks980 || bigViewportSmallScreen);
      
      // Aplica classes
      root.classList.toggle('force-mobile', isProblematic);
      root.classList.toggle('in-iframe', inIframe);
      root.classList.toggle('has-touch', isTouch || hasTouch);
      root.classList.toggle('mobile-ua', mobileUA);
      
      // Debug info (remova em produ√ß√£o)
      if (isProblematic) {
        console.log('üîß Mobile Fix Aplicado:', {
          iframe: inIframe,
          touch: isTouch || hasTouch,
          screenReal: screenRealW,
          viewport: viewportW,
          userAgent: mobileUA
        });
      }
      
      // For√ßa redimensionamento do calend√°rio
      if (isProblematic) {
        requestAnimationFrame(() => {
          const calendar = document.querySelector('.calendar-container');
          if (calendar) {
            calendar.style.width = '100%';
            calendar.style.maxWidth = 'none';
          }
        });
      }
    }
    
    // ===== AUTO-AJUSTE DE FONT-SIZE PARA COMPENSAR 980px =====
    
    function autoAdjustFontSize() {
      const root = document.documentElement;
      const isTouch = matchMedia('(pointer: coarse)').matches || 'ontouchstart' in window;
      const screenCSS = Math.min(screen.width, screen.height) || 480;
      const layoutW = window.innerWidth || 980;
      const inIframe = (window.top !== window.self);
      
      // Fator de compress√£o (quanto o layout est√° "espremido")
      const squeezeFactor = Math.max(1, layoutW / screenCSS);
      const needsCompensation = isTouch && inIframe && squeezeFactor > 1.2;
      
      if (needsCompensation) {
        // Calcula font-size compensado
        const baseFontSize = 16;
        const compensatedSize = Math.min(baseFontSize * squeezeFactor * 0.8, 28);
        
        root.style.setProperty('font-size', compensatedSize + 'px', 'important');
        
        // Ajustes espec√≠ficos para componentes cr√≠ticos
        setTimeout(() => {
          const style = document.createElement('style');
          style.textContent = `
            .force-mobile .calendar-day {
              font-size: ${Math.min(compensatedSize * 0.9, 18)}px !important;
              min-height: ${Math.min(compensatedSize * 3, 60)}px !important;
            }
            .force-mobile .btn {
              font-size: ${Math.min(compensatedSize * 0.95, 20)}px !important;
              min-height: ${Math.min(compensatedSize * 3.2, 56)}px !important;
            }
          `;
          document.head.appendChild(style);
        }, 100);
      }
    }
    
    // ===== OBSERVADOR DE MUDAN√áAS DE VIEWPORT =====
    
    let resizeTimeout;
    function handleResize() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        detectAndFixMobile();
        autoAdjustFontSize();
      }, 100);
    }
    
    // ===== INICIALIZA√á√ÉO E EVENTOS =====
    
    // Executa imediatamente
    detectAndFixMobile();
    autoAdjustFontSize();
    
    // Monitora mudan√ßas
    window.addEventListener('resize', handleResize, { passive: true });
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        detectAndFixMobile();
        autoAdjustFontSize();
      }, 200);
    });
    
    // Monitora mudan√ßas no DOM (√∫til quando o calend√°rio √© criado dinamicamente)
    const observer = new MutationObserver((mutations) => {
      let shouldRecheck = false;
      mutations.forEach(mutation => {
        if (mutation.type === 'childList') {
          const addedNodes = Array.from(mutation.addedNodes);
          if (addedNodes.some(node => 
            node.nodeType === 1 && 
            (node.classList?.contains('calendar-container') || 
             node.querySelector?.('.calendar-container'))
          )) {
            shouldRecheck = true;
          }
        }
      });
      
      if (shouldRecheck) {
        setTimeout(detectAndFixMobile, 50);
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    // ===== HELPER PARA DEBUG =====
    
    // Adiciona informa√ß√µes de debug no console (remova em produ√ß√£o)
    window.debugMobileDetection = () => {
      console.table({
        'Em iFrame': window.top !== window.self,
        'Touch Device': matchMedia('(pointer: coarse)').matches,
        'Ontouchstart': 'ontouchstart' in window,
        'MaxTouchPoints': navigator.maxTouchPoints,
        'Screen Width': screen.width,
        'Screen Height': screen.height,
        'Viewport Width': window.innerWidth,
        'Document Width': document.documentElement.clientWidth,
        'User Agent Mobile': /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
        'Force Mobile Ativo': document.documentElement.classList.contains('force-mobile')
      });
    };
    
  })();
  </script>

  <!-- ===== NOVO: CSS ADICIONAL PARA CALEND√ÅRIO RESPONSIVO ===== -->
  <style>
  /* For√ßa calend√°rio responsivo em qualquer situa√ß√£o */
  .calendar-responsive-override {
    width: 100% !important;
    max-width: none !important;
  }

  /* Container wrapper para o calend√°rio */
  #calendar-wrapper {
    width: 100%;
    overflow: hidden;
  }

  #calendar-wrapper .calendar-container {
    margin: 0 auto;
  }

  /* For√ßa mobile quando necess√°rio */
  @media screen and (max-device-width: 768px) {
    .calendar-container {
      width: 100% !important;
      max-width: none !important;
    }
  }

  /* Fallback absoluto para iframe problem√°tico */
  .force-mobile #calendar-wrapper,
  .force-mobile .calendar-container {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
  }

  /* Melhora a responsividade geral */
  .force-mobile .container {
    padding-left: 12px !important;
    padding-right: 12px !important;
    max-width: 100% !important;
  }
  </style>

</body>
</html>